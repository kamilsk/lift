package cmd

import (
	"fmt"
	"os"
	"runtime/debug"

	"github.com/mitchellh/mapstructure"
	"github.com/pelletier/go-toml"
	"github.com/pkg/errors"
	"github.com/spf13/afero"
	"github.com/spf13/cobra"
	"go.octolab.org/safe"
	"go.octolab.org/unsafe"

	"github.com/kamilsk/lift/sdk/paas"
)

const (
	app = "app.toml"
	nfr = "nfr.toml"
)

func NewCallCommand() *cobra.Command {
	fs := afero.NewOsFs()

	command := cobra.Command{
		Use:   "call",
		Short: "build app.toml or nfr.toml from components",
		Long:  "Build app.toml or nfr.toml from components.",
		Example: `
lift call components/*.toml components/*/*.toml app.toml
lift call components/prod/*.toml components/prod/quota/*.toml nfr.toml`,
		Args: func(cmd *cobra.Command, args []string) error {
			stack := []cobra.PositionalArgs{
				cobra.MinimumNArgs(2),
				func(cmd *cobra.Command, args []string) error {
					switch args[len(args)-1] {
					case app:
						return nil
					case nfr:
						return nil
					default:
						return errors.Errorf("only %s or %s are supported as last argument", app, nfr)
					}
				},
			}
			for _, check := range stack {
				if err := check(cmd, args); err != nil {
					return err
				}
			}
			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			// https://github.com/golang/go/issues/11862
			var matches []string
			for _, from := range args[:len(args)-1] {
				current, err := afero.Glob(fs, from)
				if err != nil {
					return errors.Wrapf(err, "find components for %q", from)
				}
				matches = append(matches, current...)
			}

			mode := args[len(args)-1]
			file, err := os.Create(mode)
			if err != nil {
				return errors.Wrap(err, "create output file")
			}
			defer safe.Close(file, func(err error) { panic(err) })

			if info, available := debug.ReadBuildInfo(); available {
				unsafe.DoSilent(fmt.Fprintf(file, "# Code generated by %s. DO NOT EDIT.\n\n", info.Main.Path))
			}

			// TODO:refactoring

			if mode == app {
				var app paas.Application
				for _, component := range matches {
					var src paas.Application

					tree, err := toml.LoadFile(component)
					if err != nil {
						return errors.Wrapf(err, "load component %q", component)
					}

					decoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
						Result:  &src,
						TagName: "toml",
					})
					if err != nil {
						return errors.Wrap(err, "create decoder")
					}

					if err := decoder.Decode(tree.ToMap()); err != nil {
						return errors.Wrapf(err, "decode component %q", component)
					}
					app.Merge(src)
				}
				return errors.Wrap(toml.NewEncoder(file).Encode(app), "write output file")
			}

			if mode == nfr {
				var nfr paas.NFR
				for _, component := range matches {
					var src paas.NFR

					tree, err := toml.LoadFile(component)
					if err != nil {
						return errors.Wrapf(err, "load component %q", component)
					}

					decoder, err := mapstructure.NewDecoder(&mapstructure.DecoderConfig{
						Result:  &src,
						TagName: "toml",
					})
					if err != nil {
						return errors.Wrap(err, "create decoder")
					}

					if err := decoder.Decode(tree.ToMap()); err != nil {
						return errors.Wrapf(err, "decode component %q", component)
					}
					nfr.Merge(src)
				}
				return errors.Wrap(toml.NewEncoder(file).Encode(nfr), "write output file")
			}

			return nil
		},
	}
	return &command
}
